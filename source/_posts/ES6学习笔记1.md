---
title: ES6学习笔记1
date: 2019-07-11 13:57:15
tags: ES6
---
# 07-11 个人总结

## ES6
### Array
#### find(callback(ele,index,arr))
find 方法对数组中的每一项元素执行一次 callback 函数,直至某个 callback 返回 true ,立即返回该元素的值
- `ele`:当前遍历到的元素
- `index`:当前索引
- `arr`:数组本身
- `返回值`:返回==第一个==满足条件的元素,若没有满足条件的值,返回 undefined
> find()方法不会改变原数组
#### findIndex(callback(ele,index,arr))
findIndex 方法对数组中的每个数组索引执行一次 callback 函数，直到找到一个 callback 函数返回 true 。如果找到这样的元素，findIndex 会立即返回该元素的索引。
- `ele`:当前遍历到的元素
- `index`:当前索引
- `arr`:调用findIndex的数组本身
- `返回值`:返回==第一个==满足条件的元素的索引值,若没有满足条件的元素,返回-1
> findIndex不会修改所调用的数组。
#### entries(),keys(),values()
以上三种方法均用于遍历数组,返回的都是一个遍历器对象,只是keys()是对键名的遍历,values()是对键值得遍历,entries()是对整个键值对的遍历。
- `遍历方式`:
    - next() :返回一个对象,value属性指迭代器中的元素,done指示迭代是否完成
    - for...of : 循环遍历
通过下面的实例来了解
```js
let arr = [{name: "juli",pwd: "123"},{name: "julia",pwd: "456"}]
console.log(arr.entries().next()); 
//{ value: [ 0, { name: 'juli', pwd: '123' } ], done: false }
for (const iterator of arr.entries()) {
    console.log(iterator); 
}
//[ 0, { name: 'juli', pwd: '123' } ]
//[ 1, { name: 'julia', pwd: '456' } ]
```
### 解构赋值
#### 数组的结构赋值
1. 如果解构不成功,变量的值等于 undefined ;
2. 解构赋值允许指定默认值,但 只有当一个数组成员严格等于undefined,默认值才会生效

```js
let [x=f()]=[1];  //函数 f()不会执行

```
3. 默认值可以引用结构赋值的其他变量,但必须是已经定义了的
4. 属性是有次序的,和值一一对应

#### 对象的解构赋值
1. 属性没有次序
2. 变量必须与对象的属性同名,才能取到值
3. 对象的解构赋值,可以方便地将现有对象的方法,赋值到某个变量

```js
let {log,sin,cos} = Math;
```
4. 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者
```js
let { foo: baz } = { foo: "aaa", bar: "bbb" };
bar // "aaa"
foo // error: foo is not defined
```
5. 如果解构不成功,变量的值等于undefined;
6. 也可以用来指定默认值

#### 字符串的解构赋值
1. 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
```js
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```
#### 函数参数的解构赋值
1. 函数参数的解构也可以使用默认值。

```js
function move({x = 0, y = 0} = {}) {
  return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```
2. 如果函数 foo 调用时没提供参数，变量 x 和 y 就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况

```js
function foo({x, y = 5}) {
  console.log(x, y);
}
foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```
#### 解构赋值的用处
- 交换变量的值
```javascript
let x=1,y=2;
[x,y]=[2,1];
```
- 取出从函数中返回的多个值
- 函数参数的定义
- 提取 json 数据
- 函数参数的默认值
- 遍历 Map 结构
> 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。
