---
title: 2019-07-38----2019-08-02日志
date: 2019-07-30 09:13:47
tags: 
 - 计划
---
### 待办

**2019-07-28**

- [ ] 一个数组向另一个数组转移元素

**2019-07-31**

- [ ] react refs 和 forceUpdate
- [ ] 深入理解 react 生命周期
- [ ] promise深入理解

**2019-08-01**

- [ ] 装饰器函数
- [ ] 

### Promise

- .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。
- .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。
- .then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获,需要改成以下任意一种

    ```js
    return Promise.reject(new Error('error!!!'))
    throw new Error('error!!!')
    ```

### JS技巧

- JSON.stringyfy 做序列化时的过滤

- Set 实现数组去重

- 用块级作用域解决命名冲突

- 使用参数默认值实现函数参数值的校验
    ```js
    function fix(a = require()) {
    console.log('a', a)
    }

    function require() {
      throw new Error('缺少了参数 a')
    }

    fix(1);
    // a 1

    fix();
    // Uncaught Error: 缺少了参数 a
    ```

- 用解构赋值过滤对象属性

    ```js
    // 我们想过滤掉对象 types 中的 inner 和 outer 属性
    const { inner, outer, ...restProps } = {
      inner: 'This is inner',
      outer: 'This is outer',
      v1: '1',
      v2: '2',
      v4: '3'
    };
    console.log(restProps);
    // {v1: "1", v2: "2", v4: "3"}
    ```

- 用解构赋值获取嵌套对象的属性

    ```js
    // 通过解构赋值获取嵌套对象的值
    const car = {
        model: 'bmw 2018',
        engine: {
            v6: true,
            turbo: true,
            vin: 12345
        }
    };
    // 这里使用 ES6 中的简单写法，使用 { vin } 替代 {   vin: vin }
    const modalAndVIN = ({ model, engine: { vin }})     => {
        console.log(`model: ${model}, vin: ${vin}`);
    }

    modalAndVIN(car);
    // "model: bmw 2018, vin: 12345" 
    ```

- 扩展运算符合并对象

- 使用===代替==，使用Object.is()代替===

    ![三者对比图](https://user-gold-cdn.xitu.io/2018/8/22/16561e1289dabef4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
