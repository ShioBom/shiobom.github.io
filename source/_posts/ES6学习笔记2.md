---
title: ES6学习笔记2
date: 2019-07-14 22:16:22
tags: ES6
---
# ES6 学习
## Class
- 属性表达式
可以动态属性名
```js
const balance = 'yourMoney';
class YourAccount {
    get [balance]() { return -Infinity; }
}
new YourAccount.yourMoney //-Infinity
```
- Class 表达式
下面这段代码就是声明了一个名为 person 的类,但 person 只能在类的内可用,指代当前类,在类外部,通过 personClass 引用
```js
let personClass = class person{
    getName(){
        return person.name;
    }
}
let p1 = new personClass()
```
匿名类表达式,如果类内部用不到 person,也可以省略
```js
let personClass = class {}
```
- 静态方法
    1. 在一个方法前加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用
    2. 静态方法包含 this 关键字，这个 this 指的是类，而不是实例。
    3. 父类的静态方法，可以被子类继承。
    4. 静态方法也是可以从 super 对象上调用的。
- 实例属性的定义方式
    - (1) 定义在最顶层
    - (2) 定义 constructor 内部
- 继承
**(1) super 关键字**
    - 做函数使用,代表父类构造函数,只能用于子类的构造函数之中
    - 作对象使用,在普通方法中，指向父类的原型对象；在静态方法中，指向父类。由于 super 指向父类的原型对象，所以定义在父类    实例上的方法或属性，是无法通过 super 调用的。
    - super可以调用祖辈的方法

```js
class A {iAmSuper() { return true; }}
class B extends A {}
class C extends B {iAmSuper() { return super.iAmSuper(); }}
new C().iAmSuper() //true
```

## Module
- import
    - 导入变量，可以使用as指定别名
    ```js
    import { firstName, lastName, year as y } from './profile.js';
    ```
    - import命令具有提升效果，会提升到整个模块的头部，首先执行
    ```js
    foo();
    import { foo } from 'my_module';
    ```
    - import语句会执行所加载的模块
    ```js
    import 'lodash';//指定lodash模块
    ```
    - `import * from './good'`,模块的整体加载
- export
    - 导出变量,可以用as关键字指定别名
    ```js
    // 写法一
    export var m = 1;

    // 写法二
    var m = 1;
    export {m};

    // 写法三
    var n = 1;
    export {n as m};
    ```
    - `export { firstName, lastName, year };`导出多个变量
    - 导出函数
    ```js
    export function multiply(x, y) {
    return x * y;
    };
    ```
- export default
export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字,且可以省掉花括号，如import foo from 'modules';

```js
// modules.js
function add(x, y) {
  return x * y;
}
export {add as default};
// 等同于
// export default add;

// app.js
import { default as foo } from 'modules';
// 等同于
// import foo from 'modules';
```
## Object
- 对象的属性简写

```js
const foo = 'bar';
const baz = {foo};
baz // {foo: "bar"}

// 等同于
const baz = {foo: foo};
```

- 对象的方法简写

```js
const o = {
  method() {
    return "Hello!";
  }
};
// 等同于
const o = {
  method: function() {
    return "Hello!";
  }
};
```
CommonJS模块输出一组变量，就非常适合简写

```js
let ms = {};
function getItem (key) {
  return key in ms ? ms[key] : null;
}
function setItem (key, value) {
  ms[key] = value;
}
function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
```

- 对象方法的 name 属性，返回函数名

```js
const person = {
  sayName() {
    console.log('hello!');
  },
};
person.sayName.name   // "sayName"
```
- 对象属性的遍历
ES6 一共有 5 种方法可以遍历对象的属性。

**（1）for...in** 

for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

**（2）Object.keys(obj)** 

Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

**（3）Object.getOwnPropertyNames(obj)** 

Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

**（4）Object.getOwnPropertySymbols(obj)** 

Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

**（5）Reflect.ownKeys(obj)** 

Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。

- 对象的新增方法
**（1）Object.is()** :用来比较两个值是否严格相等
```js
Object.is('foo', 'foo')// true
Object.is({}, {})// false
Object.is(NaN, NaN) // true
NaN===NaN //false
```

**（2）Object.assign(target,...source)** :用于对象的合并，将源对象（source）的所有**可枚举属性**，复制到目标对象（target）。
```js
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
//第一个参数是目标对象，后面所有的参数都是源对象
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
```
- *Object.assign常见用法*
    - 为对象添加属性
    ```js
    class Point {
      constructor(x, y) {
        Object.assign(this, {x, y});
      }
    }
    ```
    - 为对象添加方法
    ```js
    Object.assign(SomeClass.prototype, {
      someMethod(arg1, arg2) {
        ···
      },
      anotherMethod() {
        ···
      }
    });
    // 等同于下面的写法
    SomeClass.prototype.someMethod = function (arg1,    arg2) {
      ···
    };
    SomeClass.prototype.anotherMethod = function () {
      ···
    };
    ```
    - 克隆对象:只能克隆原始对象自身的值
    ```
    function clone(origin) {
      return Object.assign({}, origin);
    }
    ```
    - 合并多个对象
    ```javascript
    //将多个对象合并到某个对象。
    const merge =
      (target, ...sources) => Object.assign(target,     ...sources);
    
    //如果希望合并后返回一个新对象，可以改写上面函数，对    一个空对象合并。
    const merge =
      (...sources) => Object.assign({}, ...sources);
    ```
    - 为属性指定默认值

## Iterator
- 默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”,Symbol.iterator本身是一个==函数==。
- 执行遍历器函数，会返回一个遍历器对象，该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。
```js
const obj = {
    [Symbol.iterator] : function () {
        return {
        next: function () {
            return {
            value: 1,
            done: true
            };
        }
        };
    }
};
 ```
- 字符串也具有 Iterator 接口，它是一个类数组，字符串的iterator具有一个特殊的字符串表达
  ```js
    const s = 'abc';
    let iterator = s[Symbol.iterator]();
    const description = iterator.toString();
    description //'[object String Iterator]'
  ```
- 具有遍历器接口的就能使用for...of来遍历

## Generator
可以理解为generator函数是一个**状态机**，封装了多个内部状态，执行generator函数会返回一个遍历器==对象==，所以该函数也是一个**遍历器对象生成函数**。
- Generator函数的特点
  1. function关键字与函数名之间有一个“ * ”
  2. 函数体内部使用yield表达式，定义不同的内部状  态
  3. Generator函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行，直至遇到下一个 yield。紧跟在yield后面的那个表达式的值，作为返回的对 象的value属性值。
  4. yield表达式如果用在另一个表达式中，必须用小圆括号括起来
  5. yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。
- 由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。

```js
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}
var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}

var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }

//上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。
```
- next（）方法的参数
    yield 表达式总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。也可以接受一个函数当做参数
- return和yield的区别
    返回的对象的 done 属性，return 刚好与 yield 相反
- 给原生对象加上iterator接口
    ```js
    //方式一
    function* objectEntries(obj) {
      let propKeys = Reflect.ownKeys(obj);

      for (let propKey of propKeys) {
        yield [propKey, obj[propKey]];
      }
    }

    let jane = { first: 'Jane', last: 'Doe' };

    for (let [key, value] of objectEntries(jane)) {
      console.log(`${key}: ${value}`);
    }
    // first: Jane
    // last: Doe

    //方式二:将 Generator 函数加到对象的Symbol.iterator属性上面。
    function* objectEntries() {
      let propKeys = Object.keys(this);

      for (let propKey of propKeys) {
        yield [propKey, this[propKey]];
      }
    }

    let jane = { first: 'Jane', last: 'Doe' };

    jane[Symbol.iterator] = objectEntries;

    for (let [key, value] of jane) {
      console.log(`${key}: ${value}`);
    }
    // first: Jane
    // last: Doe
    ```

- 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以 将 Generator 函数返回的 Iterator 对象，作为参数。

    ```js
    function* numbers () {
      yield 1
      yield 2
      return 3
      yield 4
    }

    // 扩展运算符
    [...numbers()] // [1, 2]

    // Array.from 方法
    Array.from(numbers()) // [1, 2]

    // 解构赋值
    let [x, y] = numbers();
    x // 1
    y // 2

    // for...of 循环
    for (let n of numbers()) {
      console.log(n)
    }
    // 1
    // 2
    ```
## Promise
Promise对象是一个构造函数，用来生成Promise实例。Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。romise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
- **then 方法** 

then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）
```js
getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log("resolved: ", comments);
}, function funcB(err){
  console.log("rejected: ", err);
});
```
- **catch 方法**

promise 对象状态变为rejected，则会调用 catch 的回调函数，另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。
- **all 方法**

Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
```js
const p = Promise.all([p1, p2, p3]);
```
多个 Promise 实例只要有一个状态变为rejected，包装的新的实例状态就变为 rejected。
该方法必须等多个实例的状态都返回了，才会返回状态
- **race 方法**

Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
```js
const p = Promise.all([p1, p2, p3]);
```

上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
> 简洁的说，新实例的状态由第一个实例的状态决定

- **reject**

返回一个新的 Promise 实例，该实例的状态为rejected。
```js
const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) => reject('出错了'))
```
- **resolve**

返回一个新的 Promise 实例，该实例的状态为fullfilled。
```js
const p = Promise.resolve('成功了');
// 等同于
const p = new Promise((resolve, reject) => resolve('成功了'))
```

## Symbol
Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。
- Symbol 函数前不能使用new命令
- 它是一种类似于字符串的数据类型。
- Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述,便于区分
- 任意两个 Symbol 值是不相等的
- 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串
- Symbol 值不能与其他类型的值进行运算，但可以转字符串和布尔值，不能转数值
- Symbol 实例的属性 description：Symbol 的描述
- Symbol.for
接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值,会被登记在全局环境中供搜索.
- Symbol.keyFor
返回一个已登记的 Symbol 类型值的key。

```js
let s1 = Symbol.for("foo");
Symbol.keyFor(s1) // "foo"

let s2 = Symbol("foo");
Symbol.keyFor(s2) // undefined
```
## Reflect
- 从Reflect对象上可以拿到语言内部的方法。
- 修改某些Object方法的返回结果，让其变得更合理
- 让Object操作都变成函数行为
- 只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法
- 静态方法
    - `Reflect.apply(target, thisArg, args)`
    用于绑定this对象后执行给定函数。args是数组
    - `Reflect.construct(target, args)`
    提供了一种不使用new，来调用构造函数的方法，第一个参数必须是函数

    ```js
    // new 的写法
    const instance = new Greeting('张三');
    // Reflect.construct 的写法
    const instance = Reflect.construct(Greeting, ['张三']);
    ```
    - `Reflect.defineProperty(target, name, desc)`
    为对象定义属性，第一个参数必须是对象
    - `Reflect.has(target, name)`
    对应name in obj里面的in运算符。第一个参数必须是是对象
    - `Reflect.getPrototypeOf(target)`
    读取对象的__proto__属性，参数不是对象会报错
